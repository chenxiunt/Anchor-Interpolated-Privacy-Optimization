%% Header
addpath('./functions/haversine');  
addpath('./functions');

fprintf('------------------- Environment settings --------------------- \n\n');

parameters; 
city_list = {'rome', 'nyc', 'london'};

l

for city_idx = 1:length(city_list)
    city = city_list{city_idx};
    fprintf('\n------------- Processing city: %s -------------\n', city);

    %% Read map information
    node_file = sprintf('./datasets/%s/nodes.csv', city);
    edge_file = sprintf('./datasets/%s/edges.csv', city);

    opts = detectImportOptions(node_file);
    opts = setvartype(opts, 'osmid', 'int64');
    df_nodes = readtable(node_file, opts);
    df_edges = readtable(edge_file);

    col_longitude_orig = table2array(df_nodes(:, 'x'));
    col_latitude_orig = table2array(df_nodes(:, 'y'));
    col_osmid = table2array(df_nodes(:, 'osmid'));
    NR_LOC = size(df_nodes, 1);

    % Define the range of longitude and latitude
    max_longitude = max(col_longitude_orig); 
    min_longitude = min(col_longitude_orig); 
    mid_longitude = (max_longitude+min_longitude)/2;
    LONGITUDE_SIZE = max_longitude - min_longitude; 

    max_latitude = max(col_latitude_orig);   
    min_latitude = min(col_latitude_orig);  
    mid_latitude = (max_latitude+min_latitude)/2;
    LATITUDE_SIZE = max_latitude - min_latitude; 
    
    lon_range = [mid_longitude-LONGITUDE_SIZE/SCALE, mid_longitude+LONGITUDE_SIZE/SCALE];
    lat_range = [mid_latitude-LATITUDE_SIZE/SCALE, mid_latitude+LATITUDE_SIZE/SCALE];
    
    % Select the coordinates with the given range
    selected_indices = filter_coords_by_range(col_longitude_orig, col_latitude_orig, lon_range, lat_range); 

    col_longitude = col_longitude_orig(selected_indices, :); 
    col_latitude = col_latitude_orig(selected_indices, :); 

    % Convert the longitude and latitude coordinates to xy coordinates  
    [col_longitude, col_latitude] = lonlat_to_xy(col_longitude, col_latitude, mid_longitude, mid_latitude);


    NR_REAL_LOC = size(col_longitude, 1); 
    
    % Read the utiltiy loss matrix here
    path_file = sprintf('./intermediate/%s/loss_matrix_orig.mat', city);

    load(path_file);

    % Initialize metrics
    time_exp = 0; time_laplace = 0; time_tem = 0;
    time_copt = 0; time_lp = 0; time_aipo = 0; time_aipor = 0; time_bound = 0;
    loss_exp = 0; loss_laplace = 0; loss_tem = 0;
    loss_copt = 0; loss_lp = 0; loss_aipo = 0; loss_aipor = 0; loss_bound = 0;
    violation_exp = 0; violation_laplace = 0; violation_tem = 0;
    violation_copt = 0; violation_lp = 0; violation_aipo = 0; violation_aipor = 0; violation_bound = 0;
    
    prior = ones(1, NR_REAL_LOC)/NR_REAL_LOC;                               % We consider a case where vehicles are evenly distributed. 


%% ------------------------ Start running the simulation here ------------------------------
    for test_idx = 1:1:NR_TEST                                              % This for loop repeats the experiments for NR_TEST times
        samples_viocheck = randperm(NR_REAL_LOC, SAMPLE_SIZE_PPR);
        perturbed_indices = randi([1, NR_REAL_LOC], 1, NR_PER_LOC);
        loss_matrix = loss_matrix_orig(selected_indices, :); 
        loss_matrix_max = min(loss_matrix, [], 2); 
        [adjMatrix, distanceMatrix, neighborMatrix, cornerPoints, squares, lambda_x, lambda_y, corner_weights] = uniform_partition(col_latitude, col_longitude, loss_matrix_max, LONGITUDE_SIZE/(10*SCALE)*100);
        hold on;
        scatter(col_latitude(perturbed_indices), col_longitude(perturbed_indices)); 
        
        
        close all; 
        euclidean_distance_matrix_viocheck = compute_euclidean_distance_matrix(col_latitude(samples_viocheck), col_longitude(samples_viocheck)); 
        for epsilon_idx = 1:1:8                                             % This for loop indicates the different epsilon values
            EPSILON = 0.2*epsilon_idx;            
            N = NR_REAL_LOC; 
            selected_indices = 1:NR_REAL_LOC; 

            selected_longitudes = col_longitude(selected_indices);
            selected_latitudes = col_latitude(selected_indices);
            selected_osmids = col_osmid(selected_indices);
            loss_matrix_selected = loss_matrix(selected_indices, :); 
            corner_weights_selected = corner_weights(selected_indices, :); 
            
            %% Lower bound ---------------------------
            tic 
            % First calculate the utiltiy loss matrix and distance matrix
            % between grid cells
            [grid_utility_loss, grid_distances, grid_prior, ~, ~] = partition_grid_bound(selected_longitudes, selected_latitudes, loss_matrix_selected, prior, GRID_SIZE_LP, GRID_SIZE_LP, col_longitude(perturbed_indices), col_latitude(perturbed_indices), 2);
            % Then calculate the perturbation matrix using "perturbation_cal_lp"
            [z_bound, loss_bound(epsilon_idx, test_idx)] = perturbation_cal_lp(grid_utility_loss, grid_distances, grid_prior, EPSILON); 


            %% LP (Compared method) ---------------------------
            tic 
            [grid_utility_loss, grid_distances, grid_prior, ~, ~] = partition_grid(selected_longitudes, selected_latitudes, loss_matrix_selected, prior, GRID_SIZE_LP, GRID_SIZE_LP, col_longitude(perturbed_indices), col_latitude(perturbed_indices), 2); 
            [z_lp, loss_lp(epsilon_idx, test_idx)] = perturbation_cal_lp(grid_utility_loss, grid_distances, grid_prior, EPSILON); 
            % loss_lp(epsilon_idx, test_idx) = loss_lp(epsilon_idx, test_idx)/N;
            time_lp(epsilon_idx, test_idx) = toc; 
            z_lp_fine = convert_grid_to_fine_perturbation(z_lp, col_longitude, col_latitude, GRID_SIZE_LP, GRID_SIZE_LP); 
            [violation_lp(epsilon_idx, test_idx), ~] = compute_mDP_violation(z_lp_fine(samples_viocheck,:), euclidean_distance_matrix_viocheck, EPSILON); 

            %% COPT (Compared method) ---------------------------
            tic
            [grid_utility_loss, grid_distances, grid_prior, neighbor_pairs, distances_to_perturbed] = partition_grid(selected_longitudes, selected_latitudes, loss_matrix_selected, prior, GRID_SIZE_COPT, GRID_SIZE_COPT, col_longitude(perturbed_indices), col_latitude(perturbed_indices), 2); 
            [z_copt, M, loss_copt(epsilon_idx, test_idx)] = perturbation_cal_copt(distances_to_perturbed, grid_distances, grid_utility_loss, grid_prior, EPSILON, LAMBDA, R);
            time_copt(epsilon_idx, test_idx) = toc; 
            z_copt_fine = convert_grid_to_fine_perturbation(z_copt, col_longitude, col_latitude, GRID_SIZE_COPT, GRID_SIZE_COPT); 
            [violation_copt(epsilon_idx, test_idx), ppr_copt] = compute_mDP_violation(z_copt_fine(samples_viocheck,:), euclidean_distance_matrix_viocheck, EPSILON); 


            perturbed_longitudes = col_longitude(perturbed_indices);
            perturbed_latitudes = col_latitude(perturbed_indices);
            
            %% EM (Compared method) ---------------------------
            tic
            [z_em, loss_exp(epsilon_idx, test_idx)] = perturbation_cal_em(selected_longitudes, selected_latitudes, perturbed_longitudes, perturbed_latitudes, loss_matrix_selected, EPSILON); 
            time_exp(epsilon_idx, test_idx) = toc;
            [violation_exp(epsilon_idx, test_idx), ~] = compute_mDP_violation(z_em(samples_viocheck,:), euclidean_distance_matrix_viocheck, EPSILON);

            %% Laplace (Compared method) ---------------------------
            tic
            [z_laplace, loss_laplace(epsilon_idx, test_idx)] = perturbation_cal_laplace(selected_longitudes, selected_latitudes, perturbed_longitudes, perturbed_latitudes, loss_matrix_selected, EPSILON); 
            time_laplace(epsilon_idx, test_idx) = toc;
            [violation_laplace(epsilon_idx, test_idx), ~] = compute_mDP_violation(z_laplace(samples_viocheck,:), euclidean_distance_matrix_viocheck, EPSILON);
    
            %% TEM (Compared method) ---------------------------
            tic
            [z_tem, loss_tem(epsilon_idx, test_idx)] = perturbation_cal_tem(selected_longitudes, selected_latitudes, perturbed_longitudes, perturbed_latitudes, loss_matrix_selected, EPSILON);
            time_tem(epsilon_idx, test_idx) = toc;
            [violation_tem(epsilon_idx, test_idx), ~] = compute_mDP_violation(z_tem(samples_viocheck,:), euclidean_distance_matrix_viocheck, EPSILON);

            %% RMP (Compared method) ---------------------------
            tic
            loss_rmp(epsilon_idx, test_idx) = perturbation_cal_rmp(z_em, prior, loss_matrix_selected); 
            time_rmp(epsilon_idx, test_idx) = toc;
            violation_rmp(epsilon_idx, test_idx) = violation_exp(epsilon_idx, test_idx); 

            %% INT (Our method) ---------------------------
            c_approx = corner_weights_selected'*loss_matrix_selected; 
            tic
            loss_aipo = 999999999;
            for epsilon_idx_1 = 5:1:5
                epsilon_1 = EPSILON*epsilon_idx_1/10; 
                epsilon_2 = EPSILON*sqrt(1-(epsilon_idx_1/10)^2);
                z_anchor_instance = perturbation_cal_apo(c_approx, corner_weights_selected, distanceMatrix, neighborMatrix, epsilon_1/2, epsilon_2/2); 
                [z_aipo_instance, loss_aipo_instance(epsilon_idx, test_idx)] = logconv_interp(z_anchor_instance, corner_weights_selected, loss_matrix_selected);
                if loss_aipo_instance < loss_aipo
                    loss_aipo = loss_aipo_instance; 
                    z_opt_aipo = z_aipo_instance; 
                end
            end
            time_aipo(epsilon_idx, test_idx) = toc;
            [violation_aipo(epsilon_idx, test_idx), ppr_aipo] = compute_mDP_violation(z_opt_aipo(samples_viocheck,:), euclidean_distance_matrix_viocheck, EPSILON);

            %%  INT-R (Our method)
            tic
            z_anchor_opt = perturbation_cal_apo(c_approx, corner_weights_selected, distanceMatrix, neighborMatrix, EPSILON, EPSILON); 
            time_aipor(epsilon_idx, test_idx) = toc;
            [z_opt_aipor, loss_aipor(epsilon_idx, test_idx)] = logconv_interp(z_anchor_opt, corner_weights_selected, loss_matrix_selected);
            [violation_aipor(epsilon_idx, test_idx), ppr_aipor] = compute_mDP_violation(z_opt_aipor(samples_viocheck,:), euclidean_distance_matrix_viocheck, EPSILON);

            [test_idx, epsilon_idx]

        end
    end

    %% Save results with city-specific paths
    save(sprintf("./results/2norm/time/%s/time_exp.mat", city), "time_exp"); 
    save(sprintf("./results/2norm/time/%s/time_laplace.mat", city), "time_laplace"); 
    save(sprintf("./results/2norm/time/%s/time_tem.mat", city), "time_tem"); 
    save(sprintf("./results/2norm/time/%s/time_copt.mat", city), "time_copt"); 
    save(sprintf("./results/2norm/time/%s/time_lp.mat", city), "time_lp"); 
    save(sprintf("./results/2norm/time/%s/time_aipo.mat", city), "time_aipo"); 
    save(sprintf("./results/2norm/time/%s/time_aipor.mat", city), "time_aipor"); 
    save(sprintf("./results/2norm/time/%s/time_rmp.mat", city), "time_rmp"); 

    save(sprintf("./results/2norm/cost/%s/loss_exp.mat", city), "loss_exp"); 
    save(sprintf("./results/2norm/cost/%s/loss_laplace.mat", city), "loss_laplace"); 
    save(sprintf("./results/2norm/cost/%s/loss_tem.mat", city), "loss_tem"); 
    save(sprintf("./results/2norm/cost/%s/loss_copt.mat", city), "loss_copt"); 
    save(sprintf("./results/2norm/cost/%s/loss_lp.mat", city), "loss_lp"); 
    save(sprintf("./results/2norm/cost/%s/loss_aipo.mat", city), "loss_aipo"); 
    save(sprintf("./results/2norm/cost/%s/loss_aipor.mat", city), "loss_aipor"); 
    save(sprintf("./results/2norm/cost/%s/loss_bound.mat", city), "loss_bound"); 
    save(sprintf("./results/2norm/cost/%s/loss_rmp.mat", city), "loss_rmp"); 

    save(sprintf("./results/2norm/violation/%s/violation_exp.mat", city), "violation_exp"); 
    save(sprintf("./results/2norm/violation/%s/violation_laplace.mat", city), "violation_laplace"); 
    save(sprintf("./results/2norm/violation/%s/violation_tem.mat", city), "violation_tem"); 
    save(sprintf("./results/2norm/violation/%s/violation_copt.mat", city), "violation_copt"); 
    save(sprintf("./results/2norm/violation/%s/violation_lp.mat", city), "violation_lp"); 
    save(sprintf("./results/2norm/violation/%s/violation_aipo.mat", city), "violation_aipo"); 
    save(sprintf("./results/2norm/violation/%s/violation_aipor.mat", city), "violation_aipor"); 
    save(sprintf("./results/2norm/violation/%s/violation_rmp.mat", city), "violation_rmp"); 

end
