%% Header
addpath('./functions/haversine');  
addpath('./functions');

fprintf('------------------- Environment settings --------------------- \n\n');
rng("default");


NR_SAMPLES = 5; 
city_list = {'rome', 'nyc', 'london'};

for city_idx = 1:length(city_list)
    city = city_list{city_idx};
    fprintf('\n------------- Processing city: %s -------------\n', city);

    %% Read map information
    node_file = sprintf('./datasets/%s/nodes.csv', city);
    edge_file = sprintf('./datasets/%s/edges.csv', city);

    opts = detectImportOptions(node_file);
    opts = setvartype(opts, 'osmid', 'int64');
    df_nodes = readtable(node_file, opts);
    df_edges = readtable(edge_file);

    col_longitude_orig = table2array(df_nodes(:, 'x'));
    col_latitude_orig = table2array(df_nodes(:, 'y'));
    col_osmid = table2array(df_nodes(:, 'osmid'));
    NR_LOC = size(df_nodes, 1);

    SCALE = 2; 
    max_longitude = max(col_longitude_orig); 
    min_longitude = min(col_longitude_orig); 
    mid_longitude = (max_longitude+min_longitude)/2;
    LONGITUDE_SIZE = max_longitude - min_longitude; 

    max_latitude = max(col_latitude_orig);   
    min_latitude = min(col_latitude_orig);  
    mid_latitude = (max_latitude+min_latitude)/2;
    LATITUDE_SIZE = max_latitude - min_latitude; 


    lon_range = [mid_longitude-LONGITUDE_SIZE/SCALE, mid_longitude+LONGITUDE_SIZE/SCALE];
    lat_range = [mid_latitude-LATITUDE_SIZE/SCALE, mid_latitude+LATITUDE_SIZE/SCALE];
    

    selected_indices = filter_coords_by_range(col_longitude_orig, col_latitude_orig, lon_range, lat_range); 

    col_longitude = col_longitude_orig(selected_indices, :); 
    col_latitude = col_latitude_orig(selected_indices, :); 


    [col_longitude, col_latitude] = lonlat_to_xy(col_longitude, col_latitude, mid_longitude, mid_latitude);

    TASK_LOC = randi([1, NR_LOC]);
    NR_PER_LOC = 20;
    GAMMA = 2000;
    NR_VIO_SAMPLE = 1000; 
    EPSILON = 50; 
    N = NR_LOC; 

    NR_REAL_LOC = size(col_longitude, 1); 
    path_file = sprintf('./intermediate/%s/loss_matrix_orig.mat', city);

    load(path_file);

    % Initialize metrics
    time_int = 0; time_intr = 0; time_bound = 0;
    cost_exp = 0; cost_lap = 0; cost_tem = 0;
    cost_COPT = 0; cost_LP = 0; cost_int = 0; cost_intr = 0; cost_bound = 0;
    violation_exp = 0; violation_lap = 0; violation_tem = 0;
    violation_COPT = 0; violation_LP = 0; violation_int = 0; violation_intr = 0; violation_bound = 0;

    nr_anchor = 0; 


    for sample_idx = 1:1:NR_SAMPLES
        samples_viocheck = randperm(NR_LOC, NR_VIO_SAMPLE);

        euclidean_distance_matrix_viocheck = compute_euclidean_distance_matrix(col_latitude(samples_viocheck), col_longitude(samples_viocheck)); 
        for grid_size_index = 1:1:15
            perturbed_indices = randi([1, NR_LOC], 1, NR_PER_LOC);
            perturbed_longitudes = col_longitude(perturbed_indices);
            perturbed_latitudes = col_latitude(perturbed_indices);

            grid_size = grid_size_index*1; 
            perturbed_indices = randi([1, NR_LOC], 1, NR_PER_LOC);
            
            loss_matrix = loss_matrix_orig;
            loss_matrix_max = min(loss_matrix, [], 2); 
            
            [adjMatrix, distanceMatrix, neighborMatrix, cornerPoints, squares, lambda_x, lambda_y, corner_weights] = uniform_partition(col_latitude, col_longitude, loss_matrix_max, LONGITUDE_SIZE/(10*SCALE)*100);
            close all; 
            nr_anchor(grid_size_index, sample_idx) = size(cornerPoints, 1); 

            N = NR_LOC; 
            selected_indices = 1:NR_LOC; 

            selected_longitudes = col_longitude(selected_indices);
            selected_latitudes = col_latitude(selected_indices);
            selected_osmids = col_osmid(selected_indices);
            loss_matrix_selected = loss_matrix(selected_indices, :); 
            corner_weights_selected = corner_weights(selected_indices, :);

            %% Interporlation
            c_approx = corner_weights_selected'*loss_matrix_selected; 
            tic
            loss_aipo = 999999999;
            for epsilon_idx_1 = 5:1:5
                epsilon_1 = EPSILON*epsilon_idx_1/10; 
                epsilon_2 = EPSILON*sqrt(1-(epsilon_idx_1/10)^2);
                z_anchor_instance = perturbation_cal_apo(c_approx, corner_weights_selected, distanceMatrix, neighborMatrix, epsilon_1/2, epsilon_2/2); 
                [z_aipo_instance, loss_aipo_instance(grid_size_index, sample_idx)] = logconv_interp(z_anchor_instance, corner_weights_selected, loss_matrix_selected);
                if loss_aipo_instance < loss_aipo
                    loss_aipo = loss_aipo_instance; 
                    z_opt_aipo = z_aipo_instance; 
                end
            end
            time_aipo(grid_size_index, sample_idx) = toc;
            [violation_aipo(grid_size_index, sample_idx), ppr_aipo] = compute_mDP_violation(z_opt_aipo(samples_viocheck,:), euclidean_distance_matrix_viocheck, EPSILON);

        end
    end

    save(sprintf("./results/grid_size/time/%s/time_int.mat", city), "time_int"); 
    save(sprintf("./results/grid_size/cost/%s/cost_int.mat", city), "cost_int"); 
    save(sprintf("./results/grid_size/time/%s/nr_anchor.mat", city), "nr_anchor"); 

end
